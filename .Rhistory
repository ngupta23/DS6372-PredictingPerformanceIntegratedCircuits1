print(model.caret$bestTune)
id = NULL # not really needed but added for consistency
return(list(model = model.caret,id = id))
}
}
set.seed(1)
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "leapSeq"
,feature.names = feature.names)
train.caret.glmselect = function(formula, data, method
,subopt = NULL, feature.names
, train.control = NULL, tune.grid = NULL){
if(is.null(train.control)){
train.control <- trainControl(method = "cv"
,number = 10
,search = "grid"
,verboseIter = TRUE
,allowParallel = TRUE
)
}
if(is.null(tune.grid)){
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
tune.grid = data.frame(nvmax = 1:length(feature.names))
}
if (method == 'glmnet' && subopt == 'LASSO'){
# Will only show 1 Lambda value during training, but that is OK
# https://stackoverflow.com/questions/47526544/why-need-to-tune-lambda-with-carettrain-method-glmnet-and-cv-glmnet
lambda = 10^seq(-2,0, length =100)
alpha = c(1)
tune.grid = expand.grid(alpha = alpha,lambda = lambda)
}
if (method == 'glmnet' && subopt == 'LARS'){
}
}
# http://sshaikh.org/2015/05/06/parallelize-machine-learning-in-r-with-multi-core-cpus/
cl <- makeCluster(detectCores()*0.75) # use 75% of cores only, leave rest for other tasks
registerDoParallel(cl)
set.seed(1)
model.caret <- caret::train(formula
, data = data
, method = method
, tuneGrid = tune.grid
, trControl = train.control
)
stopCluster(cl)
registerDoSEQ() # register sequential engine in case you are not using this function anymore
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
print(model.caret$results) # all model results
print(model.caret$bestTune) # best model
model = model.caret$finalModel
# Provides the coefficients of the best model
id = rownames(model.caret$bestTune)
message("Coefficients of final model:")
print (coef(model, id = id))
# Need to find alternate to plotting diagnostic plots
# plot.diagnostics(model.forward,data.train)
# plot(model.forward,labels = colnames(data.train),scale=c("bic")) ## too many variables
return(list(model = model,id = id))
}
if (method == 'glmnet' && subopt == 'LASSO'){
print(model.caret)
print(plot(model.caret))
print(model.caret$bestTune)
id = NULL # not really needed but added for consistency
return(list(model = model.caret,id = id))
}
}
set.seed(1)
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "leapSeq"
,feature.names = feature.names)
stopCluster(cl)
# http://sshaikh.org/2015/05/06/parallelize-machine-learning-in-r-with-multi-core-cpus/
cl <- makeCluster(detectCores()*0.75) # use 75% of cores only, leave rest for other tasks
# http://sshaikh.org/2015/05/06/parallelize-machine-learning-in-r-with-multi-core-cpus/
cl <- makeCluster(detectCores()*0.75) # use 75% of cores only, leave rest for other tasks
registerDoParallel(cl)
registerDoParallel(cl)
stopCluster(cl)
registerDoSEQ() # register sequential engine in case you are not using this function anymore
set.seed(1)
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "leapSeq"
,feature.names = feature.names)
model.stepwise = returned$model
id = returned$id
test.model(model.stepwise, data.test
,method = 'leapSeq',subopt = NULL
,formula = formula, feature.names = feature.names, label.names = label.names
,id = id
,draw.limits = TRUE)
model.stepwise
test.model(model.stepwise, data.test
,method = 'leapSeq',subopt = NULL
,formula = formula, feature.names = feature.names, label.names = label.names
,id = id
,draw.limits = TRUE)
test.model()
id
test.model = function(model, test, level=0.95
,draw.limits = FALSE, good = 0.1, ok = 0.15
,method = NULL, subopt = NULL
,id = NULL, formula, feature.names, label.names){
## if using caret for glm select equivalent functionality,
## need to set regsubset = TRUE, pass id of best model through id variable,
## and pass formula (full is ok as it will select subset of variables from there)
if (is.null(method)){
pred = predict(model, newdata=test, interval="confidence", level = level)
}
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
pred = predict.regsubsets(model, newdata = test, id = id, formula = formula)
}
if (method == 'glmnet' && subopt == 'LASSO'){
xtest = as.matrix(test[,feature.names])
pred=as.data.frame(predict(model, xtest))
print (str(pred))
}
# Summary of predicted values
print ("Summary of predicted values: ")
print(summary(pred[,1]))
test.mse = mean((test[,label.names]-pred[,1])^2)
print (paste(method, subopt, "Test MSE:", test.mse, sep=" "))
plot(test[,label.names],pred[,1],xlab = "Actual", ylab = "Predicted")
abline(0,(1+good),col='green', lwd = 3)
abline(0,(1-good),col='green', lwd = 3)
abline(0,(1+ok),col='blue', lwd = 3)
abline(0,(1-ok),col='blue', lwd = 3)
}
# test.model(model.stepwise, data.test, "Stepwise Selection", draw.limits = TRUE, regsubset = TRUE, id = id, formula = formula)
test.model(model.stepwise, data.test
,method = 'leapSeq',subopt = NULL
,formula = formula, feature.names = feature.names, label.names = label.names
,id = id
,draw.limits = TRUE)
model.stepwise
resid(model.stepwise)
varImp(model.stepwise)
model.stepwise$ress
model.stepwise$np
model.stepwise$nrbar
model.stepwise$d
model.stepwise$rbar
model.stepwise$rss
model.stepwise$nbest
model.stepwise$tuneValue
model.stepwise$nullrss
model.stepwise$sserr
model.stepwise$method
if (algo.LASSO.caret == TRUE){
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "glmnet"
,subopt = 'LASSO'
,feature.names = feature.names)
model.LASSO.caret = returned$model
}
if (algo.LASSO.caret == TRUE){
test.model(model.LASSO.caret, data.test
,method = 'glmnet',subopt = "LASSO"
,formula = formula, feature.names = feature.names, label.names = label.names
,draw.limits = TRUE)
}
rctrl1 <- trainControl(method = "cv", number = 3, returnResamp = "all")
set.seed(849)
test_reg_cv_model <- train(formula, method = "lars", trControl = rctrl1,
preProc = c("center", "scale"))
rctrl1 <- trainControl(method = "cv", number = 3, returnResamp = "all")
set.seed(849)
test_reg_cv_model <- train(formula, data = data.train, method = "lars", trControl = rctrl1,
preProc = c("center", "scale"))
test_reg_pred <- predict(test_reg_cv_model, data.test)
test_reg_pred
str(test_reg_pred)
if (algo.LARS.caret == TRUE){
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "lars"
,subopt = 'NULL'
,feature.names = feature.names)
model.LASSO.caret = returned$model
}
if (algo.LARS.caret == TRUE){
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "lars"
,subopt = 'NULL'
,feature.names = feature.names)
model.LARS.caret = returned$model
}
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "lars"
,subopt = 'NULL'
,feature.names = feature.names)
model.LARS.caret = returned$model
str(model.LARS.caret)
train.caret.glmselect = function(formula, data, method
,subopt = NULL, feature.names
, train.control = NULL, tune.grid = NULL, pre.proc = NULL){
if(is.null(train.control)){
train.control <- trainControl(method = "cv"
,number = 10
,search = "grid"
,verboseIter = TRUE
,allowParallel = TRUE
)
}
if(is.null(tune.grid)){
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
tune.grid = data.frame(nvmax = 1:length(feature.names))
}
if (method == 'glmnet' && subopt == 'LASSO'){
# Will only show 1 Lambda value during training, but that is OK
# https://stackoverflow.com/questions/47526544/why-need-to-tune-lambda-with-carettrain-method-glmnet-and-cv-glmnet
lambda = 10^seq(-2,0, length =100)
alpha = c(1)
tune.grid = expand.grid(alpha = alpha,lambda = lambda)
}
if (method == 'glmnet' && subopt == 'lars'){
pre.proc = c("center", "scale")
}
}
# http://sshaikh.org/2015/05/06/parallelize-machine-learning-in-r-with-multi-core-cpus/
cl <- makeCluster(detectCores()*0.75) # use 75% of cores only, leave rest for other tasks
registerDoParallel(cl)
set.seed(1)
# note that the seed has to actually be set just before this function is called
# settign is above just not ensure reproducibility for some reason
model.caret <- caret::train(formula
, data = data
, method = method
, tuneGrid = tune.grid
, trControl = train.control
, preProc = pre.proc
)
stopCluster(cl)
registerDoSEQ() # register sequential engine in case you are not using this function anymore
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
print(model.caret$results) # all model results
print(model.caret$bestTune) # best model
model = model.caret$finalModel
# Provides the coefficients of the best model
id = rownames(model.caret$bestTune)
message("Coefficients of final model:")
print (coef(model, id = id))
# Need to find alternate to plotting diagnostic plots
# plot.diagnostics(model.forward,data.train)
# plot(model.forward,labels = colnames(data.train),scale=c("bic")) ## too many variables
return(list(model = model,id = id))
}
if (method == 'glmnet' && subopt == 'LASSO'){
print(model.caret)
print(plot(model.caret))
print(model.caret$bestTune)
id = NULL # not really needed but added for consistency
return(list(model = model.caret,id = id))
}
if (method == 'lars'){
print(model.caret)
print(plot(model.caret))
print(model.caret$bestTune)
id = NULL # not really needed but added for consistency
return(list(model = model.caret,id = id))
}
}
if (algo.LARS.caret == TRUE){
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "lars"
,subopt = 'NULL'
,feature.names = feature.names)
model.LARS.caret = returned$model
}
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "lars"
,subopt = 'NULL'
,feature.names = feature.names)
model.LARS.caret = returned$model
train.caret.glmselect = function(formula, data, method
,subopt = NULL, feature.names
, train.control = NULL, tune.grid = NULL, pre.proc = NULL){
if(is.null(train.control)){
train.control <- trainControl(method = "cv"
,number = 10
,search = "grid"
,verboseIter = TRUE
,allowParallel = TRUE
)
}
if(is.null(tune.grid)){
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
tune.grid = data.frame(nvmax = 1:length(feature.names))
}
if (method == 'glmnet' && subopt == 'LASSO'){
# Will only show 1 Lambda value during training, but that is OK
# https://stackoverflow.com/questions/47526544/why-need-to-tune-lambda-with-carettrain-method-glmnet-and-cv-glmnet
lambda = 10^seq(-2,0, length =100)
alpha = c(1)
tune.grid = expand.grid(alpha = alpha,lambda = lambda)
}
if (method == 'lars'){
fraction = seq(0, 1, length = 100)
tune.grid = expand.grid(fraction = fraction)
pre.proc = c("center", "scale")
}
}
# http://sshaikh.org/2015/05/06/parallelize-machine-learning-in-r-with-multi-core-cpus/
cl <- makeCluster(detectCores()*0.75) # use 75% of cores only, leave rest for other tasks
registerDoParallel(cl)
set.seed(1)
# note that the seed has to actually be set just before this function is called
# settign is above just not ensure reproducibility for some reason
model.caret <- caret::train(formula
, data = data
, method = method
, tuneGrid = tune.grid
, trControl = train.control
, preProc = pre.proc
)
stopCluster(cl)
registerDoSEQ() # register sequential engine in case you are not using this function anymore
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
print(model.caret$results) # all model results
print(model.caret$bestTune) # best model
model = model.caret$finalModel
# Provides the coefficients of the best model
id = rownames(model.caret$bestTune)
message("Coefficients of final model:")
print (coef(model, id = id))
# Need to find alternate to plotting diagnostic plots
# plot.diagnostics(model.forward,data.train)
# plot(model.forward,labels = colnames(data.train),scale=c("bic")) ## too many variables
return(list(model = model,id = id))
}
if (method == 'glmnet' && subopt == 'LASSO'){
print(model.caret)
print(plot(model.caret))
print(model.caret$bestTune)
id = NULL # not really needed but added for consistency
return(list(model = model.caret,id = id))
}
if (method == 'lars'){
print(model.caret)
print(plot(model.caret))
print(model.caret$bestTune)
id = NULL # not really needed but added for consistency
return(list(model = model.caret,id = id))
}
}
if (algo.LARS.caret == TRUE){
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "lars"
,subopt = 'NULL'
,feature.names = feature.names)
model.LARS.caret = returned$model
}
returned = train.caret.glmselect(formula = formula
,data =  data.train
,method = "lars"
,subopt = 'NULL'
,feature.names = feature.names)
model.LARS.caret = returned$model
model.LARS.caret$method
test.model = function(model, test, level=0.95
,draw.limits = FALSE, good = 0.1, ok = 0.15
,method = NULL, subopt = NULL
,id = NULL, formula, feature.names, label.names){
## if using caret for glm select equivalent functionality,
## need to set regsubset = TRUE, pass id of best model through id variable,
## and pass formula (full is ok as it will select subset of variables from there)
if (is.null(method)){
pred = predict(model, newdata=test, interval="confidence", level = level)
}
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
pred = predict.regsubsets(model, newdata = test, id = id, formula = formula)
}
if (method == 'glmnet' && subopt == 'LASSO'){
xtest = as.matrix(test[,feature.names])
pred=as.data.frame(predict(model, xtest))
}
if (method == 'glmnet' && subopt == 'LASSO'){
pred=predict(model, newdata = test)
}
# Summary of predicted values
print ("Summary of predicted values: ")
print(summary(pred[,1]))
test.mse = mean((test[,label.names]-pred[,1])^2)
print (paste(method, subopt, "Test MSE:", test.mse, sep=" "))
plot(test[,label.names],pred[,1],xlab = "Actual", ylab = "Predicted")
abline(0,(1+good),col='green', lwd = 3)
abline(0,(1-good),col='green', lwd = 3)
abline(0,(1+ok),col='blue', lwd = 3)
abline(0,(1-ok),col='blue', lwd = 3)
}
test.model(model.LARS.caret, data.test
,method = 'lars',subopt = NULL
,formula = formula, feature.names = feature.names, label.names = label.names
,draw.limits = TRUE)
test.model = function(model, test, level=0.95
,draw.limits = FALSE, good = 0.1, ok = 0.15
,method = NULL, subopt = NULL
,id = NULL, formula, feature.names, label.names){
## if using caret for glm select equivalent functionality,
## need to set regsubset = TRUE, pass id of best model through id variable,
## and pass formula (full is ok as it will select subset of variables from there)
if (is.null(method)){
pred = predict(model, newdata=test, interval="confidence", level = level)
}
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
pred = predict.regsubsets(model, newdata = test, id = id, formula = formula)
}
if (method == 'glmnet' && subopt == 'LASSO'){
xtest = as.matrix(test[,feature.names])
pred=as.data.frame(predict(model, xtest))
}
if (method == 'lars'){
pred=predict(model, newdata = test)
}
# Summary of predicted values
print ("Summary of predicted values: ")
print(summary(pred[,1]))
test.mse = mean((test[,label.names]-pred[,1])^2)
print (paste(method, subopt, "Test MSE:", test.mse, sep=" "))
plot(test[,label.names],pred[,1],xlab = "Actual", ylab = "Predicted")
abline(0,(1+good),col='green', lwd = 3)
abline(0,(1-good),col='green', lwd = 3)
abline(0,(1+ok),col='blue', lwd = 3)
abline(0,(1-ok),col='blue', lwd = 3)
}
test.model(model.LARS.caret, data.test
,method = 'lars',subopt = NULL
,formula = formula, feature.names = feature.names, label.names = label.names
,draw.limits = TRUE)
test.model = function(model, test, level=0.95
,draw.limits = FALSE, good = 0.1, ok = 0.15
,method = NULL, subopt = NULL
,id = NULL, formula, feature.names, label.names){
## if using caret for glm select equivalent functionality,
## need to set regsubset = TRUE, pass id of best model through id variable,
## and pass formula (full is ok as it will select subset of variables from there)
if (is.null(method)){
pred = predict(model, newdata=test, interval="confidence", level = level)
}
if (method == 'leapForward' | method == 'leapBackward' | method == 'leapSeq'){
pred = predict.regsubsets(model, newdata = test, id = id, formula = formula)
}
if (method == 'glmnet' && subopt == 'LASSO'){
xtest = as.matrix(test[,feature.names])
pred=as.data.frame(predict(model, xtest))
}
if (method == 'lars'){
pred=as.data.frame(predict(model, newdata = test))
}
# Summary of predicted values
print ("Summary of predicted values: ")
print(summary(pred[,1]))
test.mse = mean((test[,label.names]-pred[,1])^2)
print (paste(method, subopt, "Test MSE:", test.mse, sep=" "))
plot(test[,label.names],pred[,1],xlab = "Actual", ylab = "Predicted")
abline(0,(1+good),col='green', lwd = 3)
abline(0,(1-good),col='green', lwd = 3)
abline(0,(1+ok),col='blue', lwd = 3)
abline(0,(1-ok),col='blue', lwd = 3)
}
test.model(model.LARS.caret, data.test
,method = 'lars',subopt = NULL
,formula = formula, feature.names = feature.names, label.names = label.names
,draw.limits = TRUE)
returned = train.caret.glmselect(formula = formula
,data =  data.train2
,method = "lars"
,subopt = 'NULL'
,feature.names = feature.names)
model.LARS.caret = returned$model
test.model(model.LARS.caret, data.test
,method = 'lars',subopt = NULL
,formula = formula, feature.names = feature.names, label.names = label.names
,draw.limits = TRUE)
knitr::opts_chunk$set(echo = TRUE)
sessionInfo()
# https://gist.github.com/smithdanielle/9913897
check.packages <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
#sapply(pkg, require, character.only = TRUE)
sapply(pkg, library, character.only = TRUE) # see comment below in GitHub repo
}
# Usage example
packages<-c("dplyr", "DT", "mosaic", "MASS", "usdm", "tidyverse", "ggplot2", "PerformanceAnalytics", "caTools", "glmnet", "caret","leaps","doParallel")
check.packages(packages)
# library(dplyr)
# library(DT)
# library(mosaic)
# library(MASS)
# library(usdm) #for multicollinearity
# library(tidyverse)
# library(ggplot2)
# library(PerformanceAnalytics)
# library(caTools)
# library(glmnet)
# library(caret)
# library(leaps)
# library(doParallel)
#This line of code installs the pacman page if you do not have it installed - if you do, it simply loads the package
if(!require(pacman))install.packages("pacman")
pacman::p_load("dplyr", "DT", "mosaic", "MASS", "usdm", "tidyverse", "ggplot2", "PerformanceAnalytics", "caTools", "glmnet", "caret","leaps","doParallel", 'bbplot')
